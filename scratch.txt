                                                                .--> [Data 1]
                                                     .----> [Output 1]
                                                    /           `--> [Data N]
[Input 1] ---.                                     /
             |                                    /
[Pcap]-->[en0]---> [Head Node] --> [Packet Repeater] --> [Delay] --> [Tail Node]-----> [Output 2] --> [Data 1]
             |           ^              |                                    \
[Input N] ---'           |              v                                     \          .--> [Data 1]
                         |            [Data]                                   `-> [Queue Packets]
                         |                                                               `--> [Data N]
                         |
                   NativeHandler
                   
                   
((Pcap:en0)) 
		+-> NativePipeline[(Packet Repeater) --> (Delay)] 
			+-> IpfPipeline[(IpReassembly) --> (PacketDissector)] => :OfPacket
 

 
 
[Previous sections remain the same...]

## Payload Handling

### Specialized Payload Header

The SDK provides a specialized `Payload` header class for efficient payload access:

```java
// Create reusable headers
Packet packet = new Packet();
Ip4 ip4 = new Ip4();
Payload payload = new Payload();  // Reusable payload header

try (NetPcap pcap = NetPcap.openOffline("capture.pcap")) {
    while (pcap.nextEx(packet)) {
        if (packet.hasHeader(ip4)) {
            
            // Method 1: Zero-copy payload access
            int payloadLength = ip4.getPayload(payload);  // Binds payload to native memory, returns length
            // Access payload data without copying
            
            // Method 2: Copy payload to new byte array
            byte[] data = ip4.getPayload();  // Creates new byte array
            
            // Method 3: Copy to pre-allocated array for efficiency
            byte[] buffer = new byte[2048];
            int copied = ip4.getPayload(buffer);  // Returns bytes copied
        }
    }
}
```

### Payload Characteristics

- **Zero-Copy Access**: Using `getPayload(payload)` provides direct memory binding
- **Scope**: Like all headers, payload binding is valid only until next packet
- **Reusability**: The `Payload` header object can be reused across packets
- **Copy Options**: 
  - `getPayload()` - Returns new byte array with copied data
  - `getPayload(byte[] dst)` - Copies to pre-allocated buffer
  - `getPayload(byte[] dst, int offset, int length)` - Copies with offset/length
  - `getPayload(Payload)` - Zero-copy native memory binding

### Memory Efficiency Example

```java
public class PayloadExample {
    private final Packet packet = new Packet();
    private final Ip4 ip4 = new Ip4();
    private final Payload payload = new Payload();
    private final byte[] buffer = new byte[9000];  // Jumbo frame size

    public void processPackets(NetPcap pcap) {
        while (pcap.nextEx(packet)) {
            if (packet.hasHeader(ip4)) {
                
                // Zero-copy access for analysis
                if (ip4.getPayload(payload)) {
                    analyzePayload(payload);  // Pass native binding
                }
                
                // Copy only when needed
                if (needPayloadCopy()) {
                    int size = ip4.getPayload(buffer);
                    storePayload(buffer, size);
                }
            }
        }
    }

    private void analyzePayload(Payload payload) {
        // Work directly with native memory binding
        int size = payload.size();
        // Access payload data...
    }
}
```

[Rest of the content remains the same...]